# Лабораторная работа №2 Программирование на языке Python

### Цель работы:

#### Освоить работу с файловой системой средствами Python
#### Реализовать основные команды управления файлами и каталогами
#### Организовать журналирование действий пользователя
#### Создать расширяемую архитектуру с поддержкой плагинов

### Основные возможности(Easy):

#### 1. Команда `ls`
  - Отображение списка файлов и каталогов
  - Поддержка относительных и абсолютных путей
  - Опция `-l` для детального вывода (права доступа, размер, дата изменения)

#### 2. Команда `cd`
  - Переход в указанный каталог
  - Поддержка `..` (на уровень выше)
  - Поддержка `~` (домашний каталог)
  - Обработка ошибок при несуществующем каталоге

#### 3. Команда `cat`
  - Вывод содержимого файла в консоль
  - Проверка, что путь ведет к файлу (а не каталогу)
  - Обработка ошибок при отсутствии файла

#### 4. Команда `cp`
  - Копирование файлов и каталогов
  - Опция `-r` для рекурсивного копирования
  - Поддержка относительных и абсолютных путей
  - Проверка прав доступа и существования источника

#### 5. Команда `mv`
  - Перемещение и переименование файлов/каталогов
  - Поддержка перемещения в существующий каталог
  - Проверка существования источника

#### 6. Команда `rm`
  - Удаление файлов и каталогов
  - Опция `-r` для рекурсивного удаления
  - Подтверждение удаления каталогов
  - Защита от удаления системных каталогов (`/`, `..`, `.`)

#### 7. Логирование
  - Все операции записываются в `shell.log`
  - Формат: `[дата время] команда`
  - Запись успешных и неудачных операций
  - Отдельная запись ошибок с префиксом `ERROR:`

### Плагины(Medium):

#### 1. Поддержка архивов
    zip <папка> <архив.zip>       # создание ZIP архива
    unzip <архив.zip>             # распаковка ZIP архива
    tar <папка> <архив.tar.gz>    # создание TAR.GZ архива
    untar <архив.tar.gz>          # распаковка TAR.GZ архива`

#### 2. Поиск по содержимому
    grep <шаблон> <путь>          # поиск строк в файлах
    grep -r <шаблон> <путь>       # рекурсивный поиск в подкаталогах
    grep -i <шаблон> <путь>       # поиск без учета регистра`

#### 3. История команд и отмена
    history [N]    # вывод последних N команд
    undo           # отмена последней команды из cp/mv/rm`


### Алгоритмы работы

#### 1. Обработка путей(относительных и абсолютных)
    def resolve_path(self, path):
      if path == "~": return str(Path.home())
      if path == "..": return str(Path(self.current_dir).parent)
      if not os.path.isabs(path): path = os.path.join(self.current_dir, path)
      return os.path.normpath(path)
      
#### 2. Логирование операций
    def log(self, command, success=True, error_msg=""):
      timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
      with open(self.log_file, 'a', encoding='utf-8') as f:
        f.write(f"[{timestamp}] {command}\n")
        if not success:
          f.write(f"[{timestamp}] ERROR: {error_msg}\n")
#### 3. Система отмены(Undo)
    def undo(self):
      if not self.command_history: return "История пуста"
      last_cmd = self.command_history[-1]
      parts = last_cmd.split()
    
      if parts[0] == 'cp':
        dst = self.resolve_path(parts[2])
        if os.path.exists(dst):
          shutil.rmtree(dst) if os.path.isdir(dst) else os.remove(dst)
          self.command_history.pop()
          return f"Отменено: {last_cmd}"

#### 4. Рекурсивный поиск(grep)
    def grep(self, pattern, path, recursive=False, ignore_case=False):
      flags = re.IGNORECASE if ignore_case else 0
      results = []
    
      def search_in_file(file_path):
        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
          for i, line in enumerate(f, 1):
            if re.search(pattern, line, flags):
              results.append(f"{os.path.basename(file_path)}:{i}: {line.strip()[:100]}")
    
      if os.path.isfile(path):
        search_in_file(path)
      elif recursive:
        for root, dirs, files in os.walk(path):
          for file in files:
            search_in_file(os.path.join(root, file))
    
      return '\n'.join(results) if results else "Совпадений не найдено"

### Безопасность

  - Проверка путей - нормализация и проверка существования
  - Запрет опасных операций - нельзя удалять `/`, `..`, `.`
  - Подтверждение действий - запрос подтверждения при рекурсивном удалении
  - Корзина для удаления - файлы при `rm` с `-r` перемещаются в `.trash/`
  - Обработка исключений - все операции в `try/except` блоках

### Ограничения(основные условия ТЗ)

  - Не используются внешние оболочки (subprocess)
  - Все операции выполняются средствами Python API
  - Поддержка относительных и абсолютных путей
  - Логирование обязательно для всех команд

### Тесты

#### Тесты покрывают как успешные кейсы выполнения кода, так и неуспешные, а также есть тесты плагинов

#### Результат тестов выводится в консоль в формате:
    ============================================================
    РЕЗУЛЬТАТЫ ТЕСТИРОВАНИЯ МИНИ-ОБОЛОЧКИ
    ============================================================
    Всего тестов: 30
    Пройдено успешно: 30
    ✅ Все тесты пройдены успешно!
    ============================================================
