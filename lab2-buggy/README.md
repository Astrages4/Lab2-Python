## Отчет по лабораторной работе №2
### Ошибка 1
#### Место: `main.py`, функция `main()`, строка `if command == 'ls'`:
#### Симптом:
#### Команда ls иногда не выполняется, программа ведет себя непредсказуемо.

#### Как воспроизвести:
#### Ввести команду ls несколько раз подряд
#### Наблюдать, что иногда команда не обрабатывается

#### Отладка:
#### Установлен `breakpoint` на строке условия. В отладчике видно, что при первом вызове `command is 'ls'` возвращает `True`, но при последующих вызовах может возвращать `False`, даже если значение команды одинаковое.

#### Причина:
#### Использование оператора `is` вместо `==`. Оператор is проверяет идентичность объектов (один и тот же объект в памяти), а не равенство значений.

#### Исправление:
#### Заменено `if command is 'ls'`: на `if command == 'ls'`:

#### Проверка:
#### После исправления команда ls выполняется стабильно при любом количестве вызовов.

#### Доказательства:

1.1.jpg
1.2.jpg

### Ошибка 2
#### Место: `MiniShell.py`, метод `resolve_path()`, обработка пути `"."`
#### Симптом:
####`RecursionError: maximum recursion depth exceeded` при выполнении команды `cd` .

#### Как воспроизвести:
#### Ввести команду `cd .`
#### Получить ошибку `RecursionError`

#### Отладка:
#### Установлен `breakpoint` на строке `elif path == ".":`. При пошаговом выполнении видно, что метод вызывает сам себя бесконечно без условия выхода.

#### Причина:
#### Рекурсивный вызов `self.resolve_path(path)` для пути `"."` создает бесконечную рекурсию, так как условие `path == "."` всегда истинно.

#### Исправление:
#### Заменено `return self.resolve_path(path)` на `return self.current_dir`
#### Или вовсе убрать из кода этот кусок: `elif path == ".": return self.resolve_path(path)`

#### Проверка:
#### После исправления команда `cd .` корректно возвращает текущую директорию без ошибок.

#### Доказательства:

2.1.jpg
3.2.jpg

### Ошибка 3
#### Место: `MiniShell.py`, метод `tar()`, создание архива
#### Симптом:
#### `ValueError: Unknown archive format 'gzip'` при создании `tar` архива

#### Как воспроизвести:
#### Выполнить: `tar test_folder archive.tar.gz`
#### Получить `ValueError`

#### Отладка:
#### Установлен breakpoint на строке `shutil.make_archive(...)`. Проверка параметров показывает, что второй аргумент `'gzip'` не является допустимым форматом для `shutil.make_archive()`.

#### Причина:
#### Использован неправильный идентификатор формата архива. `shutil.make_archive()` ожидает `'gztar'` для `gzipped tar` архивов, а не `'gzip'`.

#### Исправление:
#### Заменено `'gzip'` на `'gztar'`

#### Проверка:
#### После исправления команда `tar folder archive.tar.gz` успешно создает архив.

#### Доказательства:

3.1.jpg
3.2.jpg

### Ошибка 4
#### Место: Начало файла, секция импортов
#### Симптом:
#### `ModuleNotFoundError: No module named 'shutils'` при запуске программы

#### Как воспроизвести:
#### Запустить `main.py`
#### Получить ошибку `ModuleNotFoundError`

#### Отладка:
#### Ошибка возникает на этапе импорта модулей до выполнения основной программы. В стеке вызовов видно, что импорт `shutils` не удается.

#### Причина:
#### Нет такого модуля как `shutils`.

#### Исправление:
#### Убираем из кода `import shutils`

#### Проверка:
#### После исправления программа запускается без ошибок импорта.

#### Доказательства:

4.1.jpg
4.2.jpg

### Ошибка 5
#### Место: `main.py`, проверка команды выхода
#### Симптом:
#### Команда `exi` не завершает программу

#### Как воспроизвести:
#### Ввести команду `exit`
#### Наблюдать, что программа продолжает работу

#### Отладка:
#### Установлен `breakpoint` на строке `if cmd.lower == 'exit':`. 

#### Причина:
#### Отсутствуют скобки при вызове метода `lower()`. Без скобок происходит обращение к методу как к объекту, а не его выполнение.

#### Исправление:
#### Заменено `cmd.lower` на `cmd.lower()`

#### Проверка:
#### После исправления команда `exit` корректно завершает программу.

#### Доказательства:

5.1.jpg
5.2.jpg
